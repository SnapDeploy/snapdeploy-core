// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const CountProjectsByUserID = `-- name: CountProjectsByUserID :one
SELECT COUNT(*) FROM projects
WHERE user_id = $1
`

func (q *Queries) CountProjectsByUserID(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountProjectsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateProject = `-- name: CreateProject :one
INSERT INTO projects (
    user_id,
    repository_url,
    install_command,
    build_command,
    run_command,
    language,
    custom_domain,
    require_db,
    migration_command
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, user_id, repository_url, build_command, run_command, language, created_at, updated_at, install_command, custom_domain, require_db, migration_command
`

type CreateProjectParams struct {
	UserID           uuid.UUID      `json:"user_id"`
	RepositoryUrl    string         `json:"repository_url"`
	InstallCommand   string         `json:"install_command"`
	BuildCommand     sql.NullString `json:"build_command"`
	RunCommand       string         `json:"run_command"`
	Language         string         `json:"language"`
	CustomDomain     string         `json:"custom_domain"`
	RequireDb        bool           `json:"require_db"`
	MigrationCommand sql.NullString `json:"migration_command"`
}

func (q *Queries) CreateProject(ctx context.Context, arg *CreateProjectParams) (*Project, error) {
	row := q.db.QueryRowContext(ctx, CreateProject,
		arg.UserID,
		arg.RepositoryUrl,
		arg.InstallCommand,
		arg.BuildCommand,
		arg.RunCommand,
		arg.Language,
		arg.CustomDomain,
		arg.RequireDb,
		arg.MigrationCommand,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RepositoryUrl,
		&i.BuildCommand,
		&i.RunCommand,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InstallCommand,
		&i.CustomDomain,
		&i.RequireDb,
		&i.MigrationCommand,
	)
	return &i, err
}

const DeleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, DeleteProject, id)
	return err
}

const ExistsProjectByCustomDomain = `-- name: ExistsProjectByCustomDomain :one
SELECT EXISTS(
    SELECT 1 FROM projects
    WHERE custom_domain = $1 AND custom_domain != ''
)
`

func (q *Queries) ExistsProjectByCustomDomain(ctx context.Context, customDomain string) (bool, error) {
	row := q.db.QueryRowContext(ctx, ExistsProjectByCustomDomain, customDomain)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const ExistsProjectByRepositoryURL = `-- name: ExistsProjectByRepositoryURL :one
SELECT EXISTS(
    SELECT 1 FROM projects
    WHERE user_id = $1 AND repository_url = $2
)
`

type ExistsProjectByRepositoryURLParams struct {
	UserID        uuid.UUID `json:"user_id"`
	RepositoryUrl string    `json:"repository_url"`
}

func (q *Queries) ExistsProjectByRepositoryURL(ctx context.Context, arg *ExistsProjectByRepositoryURLParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, ExistsProjectByRepositoryURL, arg.UserID, arg.RepositoryUrl)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const GetProjectByCustomDomain = `-- name: GetProjectByCustomDomain :one
SELECT id, user_id, repository_url, build_command, run_command, language, created_at, updated_at, install_command, custom_domain, require_db, migration_command FROM projects
WHERE custom_domain = $1 AND custom_domain != ''
`

func (q *Queries) GetProjectByCustomDomain(ctx context.Context, customDomain string) (*Project, error) {
	row := q.db.QueryRowContext(ctx, GetProjectByCustomDomain, customDomain)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RepositoryUrl,
		&i.BuildCommand,
		&i.RunCommand,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InstallCommand,
		&i.CustomDomain,
		&i.RequireDb,
		&i.MigrationCommand,
	)
	return &i, err
}

const GetProjectByID = `-- name: GetProjectByID :one
SELECT id, user_id, repository_url, build_command, run_command, language, created_at, updated_at, install_command, custom_domain, require_db, migration_command FROM projects
WHERE id = $1
`

func (q *Queries) GetProjectByID(ctx context.Context, id uuid.UUID) (*Project, error) {
	row := q.db.QueryRowContext(ctx, GetProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RepositoryUrl,
		&i.BuildCommand,
		&i.RunCommand,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InstallCommand,
		&i.CustomDomain,
		&i.RequireDb,
		&i.MigrationCommand,
	)
	return &i, err
}

const GetProjectByRepositoryURL = `-- name: GetProjectByRepositoryURL :one
SELECT id, user_id, repository_url, build_command, run_command, language, created_at, updated_at, install_command, custom_domain, require_db, migration_command FROM projects
WHERE user_id = $1 AND repository_url = $2
`

type GetProjectByRepositoryURLParams struct {
	UserID        uuid.UUID `json:"user_id"`
	RepositoryUrl string    `json:"repository_url"`
}

func (q *Queries) GetProjectByRepositoryURL(ctx context.Context, arg *GetProjectByRepositoryURLParams) (*Project, error) {
	row := q.db.QueryRowContext(ctx, GetProjectByRepositoryURL, arg.UserID, arg.RepositoryUrl)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RepositoryUrl,
		&i.BuildCommand,
		&i.RunCommand,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InstallCommand,
		&i.CustomDomain,
		&i.RequireDb,
		&i.MigrationCommand,
	)
	return &i, err
}

const GetProjectsByUserID = `-- name: GetProjectsByUserID :many
SELECT id, user_id, repository_url, build_command, run_command, language, created_at, updated_at, install_command, custom_domain, require_db, migration_command FROM projects
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetProjectsByUserIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) GetProjectsByUserID(ctx context.Context, arg *GetProjectsByUserIDParams) ([]*Project, error) {
	rows, err := q.db.QueryContext(ctx, GetProjectsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RepositoryUrl,
			&i.BuildCommand,
			&i.RunCommand,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InstallCommand,
			&i.CustomDomain,
			&i.RequireDb,
			&i.MigrationCommand,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateProject = `-- name: UpdateProject :one
UPDATE projects
SET
    repository_url = $2,
    install_command = $3,
    build_command = $4,
    run_command = $5,
    language = $6,
    custom_domain = $7,
    require_db = $8,
    migration_command = $9,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, user_id, repository_url, build_command, run_command, language, created_at, updated_at, install_command, custom_domain, require_db, migration_command
`

type UpdateProjectParams struct {
	ID               uuid.UUID      `json:"id"`
	RepositoryUrl    string         `json:"repository_url"`
	InstallCommand   string         `json:"install_command"`
	BuildCommand     sql.NullString `json:"build_command"`
	RunCommand       string         `json:"run_command"`
	Language         string         `json:"language"`
	CustomDomain     string         `json:"custom_domain"`
	RequireDb        bool           `json:"require_db"`
	MigrationCommand sql.NullString `json:"migration_command"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg *UpdateProjectParams) (*Project, error) {
	row := q.db.QueryRowContext(ctx, UpdateProject,
		arg.ID,
		arg.RepositoryUrl,
		arg.InstallCommand,
		arg.BuildCommand,
		arg.RunCommand,
		arg.Language,
		arg.CustomDomain,
		arg.RequireDb,
		arg.MigrationCommand,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RepositoryUrl,
		&i.BuildCommand,
		&i.RunCommand,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InstallCommand,
		&i.CustomDomain,
		&i.RequireDb,
		&i.MigrationCommand,
	)
	return &i, err
}
